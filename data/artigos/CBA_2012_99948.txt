Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

USO DE METAHEURISTICAS PARA SOLUCIONAR O PROBLEMA DE
ROTEAMENTO ABERTO DE VEICULOS COM JANELAS DE TEMPO
Jose Maurcio Costa, Sergio Ricardo de Souza, Marcone Jamilson de Freitas Souza


Av. Amazonas, 7675, Nova Gameleira
Centro Federal de Educacao Tecnologica de Minas Gerais
Belo Horizonte, Minas Gerais, Brasil


Campus Universitario, Morro do Cruzeiro
Universidade Federal de Ouro Preto
Ouro Preto, Minas Gerais, Brasil

Emails jmcosta25@gmail.com, sergio@dppg.cefetmg.br, marcone@iceb.ufop.br
Abstract This paper aims to present a study on the application of metaheuristics to solve the OVRPTW
(Open Vehicle Routing Problem with Time Windows) which is a variation of the Vehicle Routing Problem with
Time Windows Classic. The OVRPTW differs from VRPTW because there is no need to return the vehicle to the
depot, after having served the last customer of the route served by it. Given the fact that the OVRPTW is more
appropriate to model problems of logistics from the real world, is very important in logistics, having application
in different types of businesses as milk products and publishers of newspapers, for example, they need to hire
fleets of vehicles to undertake the delivery of their goods. The OVRPTW is a problem that belongs to the class
NP-hard, therefore, to fix it, is necessary to find the best Hamiltonian path for each set of clients assigned to
the route of a vehicle. Are proposed to solve the OVRPTW two hybrid algorithms based on the combined use
of metaheuristics GRASP and ILS MMAS. The algorithms were tested in six different sets of instances from
the literature, in which they demonstrated to be competitive, being able to generate better solutions than those
available for most instances used.
Open Vehicle Routing Problem with Time Windows, Optimization, Metaheuristics.

Keywords

Resumo Este trabalho tem como objetivo apresentar um estudo sobre a aplicacao de me para
resolver o PRAVJT (Problema de Roteamento Aberto de Veculos com Janelas de Tempo), que e uma variacao
do Problema de Roteamento de Veculos com Janelas de Tempo classico. O PRAVJT se difere do PRVJT por nao
haver a necessidade de o veculo retornar para o deposito, apos ter servido o ultimo cliente da rota atendido por
ele. Devido ao fato de ser mais adequado para modelar problemas de logsticas de mundo real, o PRAVJT e de
grande importancia na area de logstica, possuindo aplicacao em diferentes tipos de empresas como a de laticnios
e editoras de jornais, por exemplo, que necessitam contratar frotas de veculos para realizarem a entrega de suas
mercadorias. O PRAVJT e um problema que pertence a classe NP-difcil, pois, para soluciona-lo, e preciso
encontrar o melhor caminho hamiltoniano para cada conjunto de clientes atribudos a rota de um veculo. Sao
propostos para solucionar o PRAVJT dois algoritmos hbridos baseados no uso em conjunto das me
GRASP, MMAS e ILS. Os algoritmos propostos foram testados em seis diferentes tipos de conjuntos de instancias
encontradas na literatura especializada, em que os mesmos demonstraram ser competitivos, sendo capazes de gerar
solucoes melhores do que as existentes para a maioria das instancias utilizadas.
Palavras-chave
.

1

Problema de Roteamento Aberto de Veculos com Janelas de Tempo, Otimizacao e Me-

Introducao

Para Li et al. (2007), atualmente, devido aos custos de transporte de bens, varias empresas contratam servicos de transporte terceirizados para
realizarem a entrega de seus produtos. Com isso,
e possvel obter uma significante reducao sobre os
gastos da empresa para os servicos de entrega de
mercadorias para seus clientes. Desta forma, nao
ha uma preocupacao por parte da empresa com a
volta os veculos para o ponto de partida. Situacoes como essa caracterizam o Problema de Roteamento Aberto de Veculos (PRAV), que e uma
variante do Problema de Roteamento de Veculos
(PRV) Classico. No PRAV, o veculo nao retorna
para o deposito apos visitar o ultimo cliente da
rota atendida por ele. Alem disso, diferentemente
do PRV, em que as rotas representam ciclos Hamiltonianos, no PRAV essas rotas representam caminhos Hamiltonianos. Brandao (2004) diz que o

ISBN 978-85-8001-069-5

PRAV e um problema de otimizacao_combinatoria
que consiste em encontrar as melhores rotas para
uma frota de veculos, que, por sua vez, devem
atender um conjunto de cidades com demanda e
localizacao geografica conhecidas.
De acordo com Brandao (2004), o PRV e
um problema de otimizacao NPdifcil. Deste
modo, o uso de heursticas e me para
a sua solucao se justificam. Neste trabalho, e estudada uma variante do PRAV, que e o Problema
de Roteamento Aberto de Veculos com Janelas de
Tempo (PRAVJT). No PRAVJT, alem das restricoes do PRAV, sao consideradas restricoes definidas por janelas de tempo, que indicam os perodos
de atendimento dos clientes.
Segundo Brandao (2004), o PRAV foi mencionado primeiramente no trabalho desenvolvido
por Schrage (1981), que descrevia problemas de
roteamento reais e suas aplicacoes.
Brandao
(2004) desenvolveu em sua pesquisa um algoritmo

3244

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

baseado na metaheurstica Busca Tabu para explorar a estrutura do PRAV. Este algoritmo utiliza dois metodos para a geracao da solucao inicial que sao a heurstica do vizinho mais proximo (Nearest Neighbour Heuristic) e o procedimento US (Unstringing and Stringing). Letchford et al. (2006) implementaram em seu trabalho
um algoritmo exato para resolver o PRAV baseado no metodo Branch-and-Cut. Repoussis et al.
(2006) usaram uma heurstica de construcao de
rotas gulosa com olhar a frente para solucionar o PRAVJT. Esta heurstica utiliza as informacoes das janelas de tempo integrantes do problema atraves da combinacao da selecao dos clientes e do criterio de insercao de rotas. Guiyun
(2009) pesquisou o PRAVJT e desenvolveu um
algoritmo baseado na metaheurstica Colonia de
Formigas para soluciona-lo. Este algoritmo foi implementado de forma que o processo de construcao
das solucoes e feito pelas formigas de forma paralela, ou seja, varias solucoes sao criadas ao mesmo
tempo e as formigas tambem interagem entre si,
de modo que utilizam informacoes referentes as
trilhas de feromonio das solucoes que sao construdas umas das outras. Repoussis et al. (2009)
propuseram o uso de um algoritmo evolucionario
para resolver o PRAVJT. Nele, a cada iteracao,
uma nova populacao e gerada por meio do processo de mutacao, que, por sua vez, e baseado
nas arestas extradas de pais individuais. As solucoes referentes aos filhos gerados sao melhoradas
atraves do algoritmo Busca Tabu. Neste estudo,
foram utilizados os algoritmos hbridos GRASPILS e GRASP-MMAS-ILS para tentar solucionar
o PRAVJT, que consistem na combinacao entre as
me GRASP, Max-Min Ant System e
ILS. O artigo esta organizado da seguinte forma
a secao 2 apresenta a descricao do problema. A
secao 3 mostra a metodologia utilizada neste trabalho. Os resultados dos experimentos computacionais sao discutidos na secao 4. As conclusoes
sobre o estudo estao na secao 5.
2

Caracterizacao do Problema

O PRAJT pode ser representado na forma de um
grafo completo e naodirecionado, que possui um
conjunto V de vertices e um conjunto A de arestas.
O conjunto de vertices do grafo e dado por V 
1, 2, . . . , N , o que inclui o deposito, e os demais
vertices sao os clientes a serem atendidos pelos veculos a partir do deposito. O conjunto A de arestas e definido como A  (i, j) i, j  V, i 6 j.
Cada aresta (i, j) esta associada a distancia dij
entre os vertices respectivos. O conjunto de veculos e definido por K  1, 2, . . . , K, em que o
ndice k conta os veculos. O conjunto de clientes
e C  2, 3, . . . , N , em que cada cliente i possui
uma demanda qi , que deve ser atendida por apenas um veculo. No PRAVJT, a frota de veculos e

ISBN 978-85-8001-069-5

homogenea e, desse modo, todos os veculos possuem a mesma capacidade Q. Alem disso, cada
veculo deve atender um subconjunto de clientes
em sua rota, que comeca no deposito e termina
no ultimo cliente. De acordo com MirHassani
and Abolghasemi (2011), o PRAVJT e um problema de otimizacao_combinatoria que consiste em
encontrar o numero mnimo de rotas, de forma
que sejam respeitadas as restricoes que compoem
este problema. No PRAVJT, procura-se, primeiramente, minimizar o numero de veculos que sao
necessarios para atender aos clientes, para que, em
seguida, seja feita a minimizacao da distancia total de viagem do numero de rotas obtidas. Com
isso, e prefervel obter uma solucao que necessite
de menor numero de veculos e percorra maior distancia de viagem, em vez de uma solucao que utilize mais veculos que caminhem por distancias de
viagem menores. Nesse problema, cada cliente e
visitado apenas uma vez por um veculo, e a capacidade de cada veculo nao pode ser ultrapassada.
Conforme Repoussis et al. (2006), o PRAVJT
se difere do PRAV devido a adicao das restricoes
de tempo que fazem parte dele. No PRAVJT,
cada cliente Ci deve ser atendido de acordo com
a sua respectiva janela de tempo, que modela o
intervalo de tempo ei , li , em que tal cliente pode
ser atendido. Os valores ei e li sao os tempos inicial e final referentes ao perodo de atendimento do
cliente, respectivamente. Alem disso, cada cliente
requer um tempo de servico si , que e o perodo
de tempo que o veculo deve aguardar para efetuar suas tarefas. Assim, a soma dos tempos de
viagem e dos tempos de servico das cidades ja visitadas por um veculo deve ser maior ou igual ao
horario inicial, e menor que o horario final de atendimento da janela de tempo associada ao proximo
cliente a ser visitado. Caso o veculo chegue mais
cedo ao consumidor, ele pode esperar o incio da
janela de tempo no local. O tempo de servico so
pode comecar dentro da janela de tempo e assim
que o veculo chega. Associados com a sequencia i de clientes para os clientes j, ha um custo
cij , um tempo de viagem tij e uma distancia dij .
Assume-se tambem que cij , tij e dij sao medidas
equivalentes, com ajustamentos adequados.
3
3.1

Metodologia

Representacao de Uma Solucao

Uma solucao para o PRAVJT e representada atraves de um vetor solucao que armazena uma permutacao de cidades, numeradas de 1 a n, que sao
separadas de acordo com o numero de rotas criadas. O valor zero e utilizado como elemento separador, que indica o deposito. Como exemplo,
considere uma regiao onde existam 8 cidades, que
possam ser atendidas por 3 caminhoes. O vetor
solucao para este caso seria S   0, 2, 5, 7, 0, 3,

3245

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

6, 4, 0, 8, 1, 9 , em que  0, 2, 5, 7 ,  0, 3, 6, 4 
e  0, 8, 1, 9  seriam as rotas desta solucao.
3.2

Funcao de avaliacao

Uma solucao s  S gerada pelo algoritmo e avaliada pela funcao representada pela expressao (1),
que calcula o custo de deslocamento dos veculos,
ou seja, o total das distancias percorridas por todos os veculos em suas respectivas rotas.
X
f (s) 
dij xij
(1)
(ij)A

Sendo A o conjunto das arestas, o custo de deslocamento de um cliente i para o cliente j e definido
por dij . A variavel xij serve para indicar se o arco
(i, j) faz parte da solucao, recebendo valor 1 neste
caso e 0, caso contrario.
3.3

Estrutura de Vizinhanca

O espaco de busca consiste no conjunto de solucoes
s  S que pertencem ao PRAVJT, em que se procura obter novas solucoes por meio de movimentos
de troca e realocacao para a geracao de vizinhos
de s. Neste trabalho, foram utilizadas dez diferentes estruturas de vizinhanca para se explorar o
espaco de busca. Com isso, foram utilizados movimentos que consistem na modificacao de apenas
uma rota (intrarotas) e movimentos que alteram duas rotas (interrotas). Os movimentos do
tipo intra-rota sao o Shift (1), Shift (2), Shift (3)
e Exchange. Os movimentos do tipo interrota
sao Shift (1,0), Shift (2,0), Shift (3,0), Swap(1,1),
Swap(2,1) e Swap(2,2). Os movimentos do tipo
Shift (k) consistem na transferencia de k clientes
adjacentes para outra posicao da rota a qual pertencem. O movimento Exchange consiste na permutacao entre dois clientes de uma mesma rota.
Os movimentos do tipo Shift (k,0) sao semelhantes
aos do tipo Shift (k), porem realizam a alteracao
de duas rotas por meio da realocacao de k clientes
adjacentes de uma rota para outra. Os movimentos do tipo Swap(k,l) tambem alteram duas rotas
quando realizados, permutando k clientes adjacentes de uma rota com l clientes adjacentes de outra.
Alem dos movimentos descritos anteriormente, sao tambem utilizados outros dois movimentos
ER (Elimina Rota) e o ERFO
(Elimina Rota Funcao Objetivo). O movimento
ER(Elimina Rota) consiste na tentativa de eliminar uma rota da solucao. Primeiramente, escolhese a menor rota para tentar elimina-la por meio
da retirada dos clientes pertencentes a ela. Com
isso, busca-se inserir os clientes removidos da rota
escolhida, inserindo-os nas demais rotas da solucao, dando-se preferencia para as rotas maiores.
Se todos os clientes retirados da rota escolhida forem inseridos nas demais rotas, o procedimento
termina. Quando nao e possvel inserir um dos

ISBN 978-85-8001-069-5

clientes removidos da rota escolhida em nenhuma
das outras rotas, esta rota permanece inalterada
e o processo e aplicado para as demais rotas, ate
que seja minimizado o numero de rotas ou ate que
a maior delas seja tambem analisada para a sua
eliminacao. O movimento ERFO (Elimina Rota
Funcao Objetivo) e semelhante ao ER, porem, o
procedimento termina quando todos os clientes da
rota escolhida sao retirados e inseridos nas demais
rotas ou o valor da funcao objetivo e minimizado.
O ERFO tambem termina quando todas as rotas,
a partir da menor para a maior, sao analisadas
para serem eliminadas.
3.4

PFIH

A heurstica PFIH (Push Forward Insertion Heuristic) foi proposta por Solomon (1987) para a
construcao de solucoes para o PRVJT. O PFIH
consiste em um algoritmo de construcao que realiza a insercao das cidades nas rotas, de acordo
com o seu custo de insercao. O custo de insercao das cidades e calculado de acordo com a sua
distancia geografica, limitante superior da janela
de tempo, e o angulo polar entre a cidade e o deposito. Assim, quando uma cidade e designada
para ser inserida na solucao, o seu custo de insercao e verificado em todas as possveis posicoes das
rotas pertencentes a solucao corrente. Quando e
analisado o custo de insercao de uma cidade, e
tambem verificado se o atendimento dela em determinada posicao nao viola as restricoes das janelas de tempo e de carga dos consumidores. Com
isso, apos a analise da insercao da cidade em todas as posicoes da solucao, e escolhida a posicao
em que o atendimento dela apresentar o menor
custo, ou seja, a menor distancia total percorrida.
A sequencia em que os consumidores sao escolhidos para serem inseridos na solucao e determinada
pela expressao (2)
h p  i
i
ci  d0i + bi + .
d0i i  C (2)
360
Na funcao (2), os parametros   0, 7   0, 1 e
  0, 2 foram definidos por Solomon (1987) de
forma emprica d0i e a distancia entre o deposito e
o consumidor i bi e o limitante superior da janela
de tempo do consumidor i e pi e o angulo polar do consumidor i em relacao ao deposito. Com
isso, Solomon (1987) desenvolveu tal funcao para
determinar a ordem de insercao dos consumidores
na solucao com base nas caractersticas do problema como o distancia entre os clientes e suas
janelas de tempo.
3.5

GRASP

Proposta por Feo and Resende (1995), a metaheurstica GRASP (Greedy Randomized Adaptive Search Procedure) e composta por duas fases,
denominadas fase de construcao e fase de busca

3246

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

local. Na fase de construcao, uma solucao e gerada elemento a elemento na fase de busca local,
e feita uma pesquisa por um otimo local na vizinhanca da solucao construda. Desse modo, a
melhor solucao obtida ao longo do processo de todas as iteracoes realizadas do GRASP e retornada
como resultado. Para a geracao de uma solucao
inicial para o PRAVJT, a fase de construcao foi
desenvolvida com base na heurstica de PFIH.
A cada iteracao, uma das cidades ainda nao
atendidas e escolhida para ser inserida na solucao corrente, de acordo com a ordem definida pela
funcao (2) do PFIH. O algoritmo analisa todas as
posicoes em que a cidade pode ser atendida sem
que sejam violadas as restricoes que compoem o
PRAVJT. Todas as possveis opcoes referentes as
posicoes de insercao da cidade sao armazenadas
em uma lista de candidatos de forma ordenada.
Estas opcoes sao ordenadas na lista de acordo com
o seu benefcio, ou seja, valor da funcao objetivo
caso a cidade seja inserida em determinada posicao. Com base na funcao adaptativa gulosa que
compoe o procedimento de construcao do GRASP,
sao escolhidos, a partir da lista de candidatos, os
melhores elementos (posicoes) para compor a lista
de candidatos restrita (LCR). Para controlar o nvel de gulosidade e aleatoriedade da funcao de escolha do elementos da LCR, e utilizado o parametro , que pode possuir valores no intervalo entre
0 e 1. Quanto mais proximo o valor de  for de
0, mais gulosas serao as solucoes, enquanto que as
solucoes serao mais aleatorias quando o valor de 
se aproximar de 1. Dentre os elementos da lista de
candidatos restrita, e escolhido um elemento para
ser inserido em uma das rotas.
A cada iteracao do processo de construcao,
sao atualizadas a lista de candidatos e a lista de
candidatos restrita. Caso nao seja possvel a insercao do cliente, e criada uma nova rota. O processo
de construcao e realizado ate que todos os clientes
sejam atendidos. Apos o processo de construcao,
e feita a busca local para se pesquisar por um novo
otimo local. Para a realizacao da busca local sobre as solucoes geradas pelo processo de construcao, foi utilizado o metodo de primeira melhora,
que consiste na exploracao da vizinhanca ate que
um melhor vizinho seja encontrado. No metodo
de busca local, sao utilizados os movimentos ER
e ERFO descritos na secao 3.3. Com isso, evitase uma pesquisa exaustiva por toda a vizinhanca.
Assim, apenas no pior caso toda a vizinhanca e
explorada.
3.6

Max-Min Ant System

Proposta por Dorigo et al. (1996), a metaheurstica Colonia de Formigas e um metodo baseado no comportamento de formigas para realizar
a busca por alimento. Nele, um conjunto formigas
artificiais constroem solucoes para um problema

ISBN 978-85-8001-069-5

de otimizacao, onde elas cooperam entre si trocando informacoes sobre a qualidade das solucoes
que constroem. A troca de informacoes e feita
por meio do feromonio depositado por cada uma
das formigas ao se moverem dentro do espaco de
busca, onde a trilha deixada por elas e usada como
informacao pelas demais formigas. De acordo com
Dorigo and Stutzle (2003), as formigas utilizadas
no metodo sao procedimentos de construcao de
solucoes estocasticas, que criam solucoes por meio
de criterios de escolha probabilsticos durante as
iteracoes do processo. Os movimentos produzidos
pelas formigas sao realizados com base em uma
poltica de decisao local estocastica que se utiliza
das trilhas de feromonio e de informacoes heursticas. Durante a etapa de construcao, a formiga
avalia a solucao parcial ou completa e deposita o
feromonio sobre os componentes ou conexoes que
ela usou. A informacao de feromonio sera usada
para direcionar as proximas buscas a serem feitas
pelas formigas. Essa escolha e feita de acordo com
a seguinte probabilidade


pkij  P



(ij ) (ij )


lNik



(il ) (il )

, se j  Nik ,

(3)

Na equacao (3), Nik representa o conjunto de cidades ainda nao visitadas pela formiga k  e 
servem para determinar a influencia relativa da
trilha de feromonio e da informacao heurstica
parametro Nij  d1ij e uma informacao heurstica
disponvel a priori.
A metaheurstica Colonia de Formigas possui
outros dois procedimentos que sao o de evaporacao das trilhas de feromonio e as acoes daemon. O
processo de evaporacao de feromonio consiste na
sua diminuicao ao longo do tempo. Tal processo
de evaporacao serve para evitar uma convergencia
muito rapida do algoritmo para regioes sub otimas. Desse modo, e implementada uma forma util
de esquecimento que favorece a exploracao de novas regioes do espaco de busca. As acoes Daemon
sao usadas para implementar acoes centralizadas,
que nao podem ser realizadas pelas formigas apenas. A construcao de uma solucao termina apos
todas as formigas criarem os seus caminhos. Em
seguida, as trilhas de feromonio sao atualizadas,
onde e feita a evaporacao das mesmas, para que
depois cada formiga possa realizar o deposito de
feromonio sobre as arestas pertencentes ao seu caminho.
A metaheurstica MAX-MIN Ant System e
uma das variacoes do algoritmo Ant System e foi
desenvolvida por Stutzle and Hoos (1996). Para
Stutzle and Hoos (2000), por meio de uma forte
exploracao das melhores solucoes encontradas durante o processo de pesquisa e da analise do espaco
de busca, e possvel obter melhores resultados, porem, a realizacao de uma pesquisa de forma gulosa faz com que ocorra uma convergencia rapida

3247

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

do algoritmo. Com isso, o MAX-MIN Ant System
veio da ideia de realizar um maior aproveitamento
das melhores solucoes encontradas no processo de
busca e, ao mesmo tempo, utilizar um mecanismo
para se evitar a estagnacao precoce do processo
de pesquisa. Segundo Stutzle and Hoos (2000),
a atualizacao das trilhas de feromonio no MAXMIN Ant System e feita apenas pela formiga que
encontrou a melhor solucao da iteracao (sib ) ou
a melhor solucao desde o incio da execucao do
algoritmo (sgb ) ao final de uma iteracao. A equacao 4 abaixo caracteriza a forma como e feita a
atualizacao das trilhas de feromonio.
ij (t + 1)  ij (t) + ijbest

(4)

Na equacao 4, 0 << 1 e a taxa de evaporacao da trilha de feromonio, ijbest e definido por


ijbest  1f sbest e f sbest e o valor referente
ao custo de sib ou sgb . Deve ser feito tanto o uso
de sib quanto o de sgb , em vez de apenas uma delas
para torna a exploracao do espaco de busca mais
diversificada, evitando uma convergencia precoce
de tal exploracao, ja que os elementos que compoem sib tambem terao as suas respectivas trilhas
de feromonio atualizadas. O emprego de limitantes para controlar a concentracao de feromonio
e impedir a rapida estagnacao do procedimento
de pesquisa e outra importante caracterstica do
MAX-MIN Ant System. Na atualizacao das trilhas de feromonio sao usados dois limitantes, um
inferior (min ) e outro superior (max ) para regular a quantidade de feromonio que as trilhas possuem. Ao final de cada iteracao, deve ser verificado se a concentracao de feromonio nas trilhas
respeita os limites min e max definidos. Tal verificacao e feita de acordo com a seguinte a regra

min Se ij (t) < min
ij (t) 
(5)
max Se ij (t) > max
Conforme Dorigo et al. (2006), os valores de min
e max podem ser definidos tanto de forma emprica como analtica. No MAX-MIN Ant System,
normalmente, a quantidade de feromonio inicial
(0 ) das trilhas e igual a max . Esta medida e
adotada, pois assim e possvel se ter uma melhor
exploracao do espaco de busca no incio do algoritmo.
3.7

Iterated Local Search

Segundo Lourenco et al. (2003), o algoritmo de
Busca Local Iterativa (ILS) trabalha de modo que
o processo de busca local pode ser melhorado, gerando novas solucoes de partida, de forma que tais
solucoes sao obtidas por meio de pertubacoes na
solucao otima local. Neste trabalho, o ILS foi utilizado para refinar as solucoes obtidas por meio do
MAXMIN Ant System, ou seja, ele foi utilizado
como componente de geracao de uma solucao inicial para o problema. O processo de pertubacao

ISBN 978-85-8001-069-5

do ILS consiste na aplicacao de diferentes nveis
de perturbacao na solucao corrente. Caso nao seja
obtida uma solucao melhor, o nvel de perturbacao sobre tal solucao e aumentado ate um determinado limite. No algoritmo ILS implementado
foram utilizados os movimentos do tipo Shift(k),
Shift(k,0), ER e ERFO. A pertubacoes realizadas
nesta versao do ILS consistem na aplicacao de 2 a
9 movimentos do tipo Shift(k) ou Shift(k,0). No
caso das perturbacoes feitas por meio dos movimentos ER ou ERFO, tais movimentos sao aplicados apenas uma vez. Apos a pertubacao e aplicado o processo de busca local por meio do metodo
VND (Variable Neighborhood Descent) proposto
por Mladenovic and Hansen (1997), em que sao
utilizados todos os movimentos descritos na secao
3.3, exceto o ER e o ERFO. A cada iteracao do
ILS, a solucao obtida e avaliada por meio do procedimento de aceitacao para definir de qual sera a
solucao no proximo procedimento de perturbacao.
3.8

Algoritmos Hbridos Desenvolvidos

Neste estudo foram desenvolvidos os algoritmos
hbridos GRASP+ILS e GRASP+MMAS+ILS
para solucionar o PRAVJT, em que o primeiro
consiste na combinacao entre as me GRASP e ILS e o segundo entre as me GRASP, MaxMin Ant System e
ILS. No algoritmo GRASP+ILS, a metaheurstica
GRASP foi responsavel pela geracao da solucao
inicial e o ILS pelo seu refinamento. No algoritmo GRASP+MMAS+ILS, a solucao inicial do
MMAS foi gerada pelo GRASP, para que a mesma
pudesse ser melhorada por meio do MMAS, ja o
refinamento da solucao gerada atraves do uso dos
algoritmos anteriores foi realizado pelo ILS. No
GRASP+MMAS+ILS, o MMAS foi desenvolvido
de maneira que a forma como as formigas utilizadas constroem as suas solucoes foi baseada na
heurstica construtiva PFIH . Assim, de acordo
com a ordem de atendimento das cidades definida
pela funcao (2) do PFIH, a formiga analisa todas
as possveis posicoes onde a cidade pode ser atendida e em vez de escolher de maneira gulosa como
no PFIH, tal formiga escolhe a posicao de insercao da cidade na solucao corrente de acordo com
a regra de decisao (3). Na expressao (3), ij se
refere a concentracao de feromonios do arco (i, j)
que liga o cliente a ser atendido com a cidade ou
deposito anterior a ele, na posicao em que e verificada a sua insercao. O valor de ij e o custo
de insercao da cidade em determinada posicao da
solucao.
4

Experimentos Computacionais

Os algoritmos propostos foram desenvolvidos
em linguagem C++, por meio do compilador
Gnu GCC. O algoritmo foi executado em um

3248

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

computador com processador Pentium Intel(R)
Core(TM)2 Quad Q8400, com clock de 2.66
GHz, 3, 7 GB de RAM, sob a plataforma Windows Seven Ultimate. Para testar os algoritmos GRASP+ILS e GRASP+MMAS+ILS, foram
utilizadas as instancias proposta por Solomon
(1987). Sao instancias que se dividem nos grupos
C, R e RC. No conjunto de instancias C, os clientes
sao localizados proximos uns dos outros, formando
grupos. No conjunto de instancias R, os clientes
estao localizados em posicoes aleatorias sem agrupamento. No caso do grupo de instancias RC, ha
tanto clientes localizados proximos uns dos outros
como no conjunto C quanto em posicoes distantes
como no conjunto R. Foram utilizados os conjuntos de instancias do tipo C1, R1, RC1, C2, R2 e
RC2. Os conjuntos de instancias utilizadas para
a realizacao deste trabalho possuem 100 clientes.
A capacidade Q dos veculos nos conjuntos de instancias usadas e igual a 200 unidades. O algoritmo
proposto foi executado trinta vezes para cada uma
das instancias utilizadas. Os parametros utilizados para a execucao do algoritmo MaxMin Ant
System sao   1,   5,   0, 5 para a execucao
do GRASP,   0, 30, valores estes estabelecidos
de forma emprica, apos a realizacao de testes.
Para fins de comparacao, as tabelas 1 e 2
apresentam os dados referentes a distancia percorrida e ao numero de veculos das rotas construdas pela heurstica desenvolvida por Repoussis
et al. (2009) e pelo GRASP+ILS. As tabelas 3 e 4
contem as informacoes acerca da distancia percorrida e do numero de veculos das rotas construdas
pela heurstica desenvolvida por Repoussis et al.
(2009) e pelo GRASP+MMAS+ILS.
Conforme os dados das tabelas a serem apresentadas, percebe-se que os algoritmos propostos demonstraram ser competitivos em comparacao com os resultados apresentados por Repoussis et al. (2009). O algoritmo GRASP+ILS
foi capaz de encontrar novas solucoes para mais
de 58, 33 das instancias do conjunto R1, apesar de nao ter encontrado solucoes melhores do
que as apresentadas na literatura para o conjunto
R2, os resultados alcancados pelo algoritmo foram proximos. Para os conjuntos de instancias
C1 e C2, o GRASP+ILS foi capaz de encontrar novas solucoes em 100 e 87, 5 das instancias testadas, respectivamente. Ao ser aplicado sobre os problemas-teste das instancias RC1
e RC2, o GRASP+ILS apresentou novas solucoes
em 87, 5 e 12, 5 das instancias testadas, respectivamente.
O algoritmo GRASP+MMAS+ILS ao ser
aplicado sobre o conjunto de instancias R1, ele
encontrou novas solucoes em 50 das instancias testadas, ja para o conjunto de instancias
R2, tal algoritmo nao foi capaz de encontrar
solucoes melhores do que as presentes, porem,
apresentou resultados com valores proximos. O

ISBN 978-85-8001-069-5

GRASP+MMAS+ILS apresentou bons resultados
ao ser utilizado para solucionar os problemas testes dos conjuntos C1 e C2, em que ele foi capaz
de encontrar solucoes melhores do que as da literatura em 100 e 75 dos casos, respectivamente. Em relacao aos conjuntos de instancias
RC1 e RC2, o GRASP+MMAS+ILS encontrou
solucoes melhores do que as presentes na literatura para 75 e 12, 5 das instancias, respectivamente.
Na comparacao entre os resultados
obtidos pelos algoritmos GRASP+ILS e
GRASP+MMAS+ILS, percebe-se que para
o conjunto de instancias R1 o primeiro foi
capaz de encontrar solucoes melhores do que o
segundo em 41.67 das instancias e o segundo
foi gerou solucoes melhores do que o primeiro
algoritmo em 50 das instancias, enquanto
que em 8, 33 dos testes houve empate entre
eles. Em relacao ao conjunto de instancias R2 o
GRASP+ILS encontrou solucoes melhores do que
o GRASP+MMAS+ILS em 63, 64 das instancias. O GRASP+ILS e o GRASP+MMAS+ILS
obtiveram empate para todas as instancias
testadas do conjunto C1. No caso do conjunto
de instancias C2, os dois algoritmos utilizados
empataram em 75 das instancias testadas, para
as demais instancias do conjunto, um algoritmo
encontrou resultados melhores do que o outro em
12, 5 dos casos. O GRASP+ILS apresentou resultados melhores do que o GRASP+MMAS+ILS
em 62, 5 das instancias dos conjuntos RC1 e
RC2.

Tabela 1 Resultados para R1, C1 e RC1
Repoussis (2009)
Conjunto

GRASP+ILS

Distancia

Veculos

Distancia

Veculos

R101

1192.85

19

1195.13

18

R102

1079.39

17

1046.29

17

R103

1016.78

13

984.97

13

R104

869.63

9

791.43

9

R105

1055.04

14

1123.85

13

R106

1000.95

12

994.82

12

R107

912.99

10

921.37

10

R108

760.3

9

777.6

9

R109

934.53

11

954.19

11

R110

846.49

10

904.16

10

R111

895.21

10

887.21

10

R112

811.73

9

750.21

10

C101

556.18

10

556.03

10

C102

556.18

10

556.03

10

C103

556.18

10

556.03

10

C104

555.41

10

555.27

10

C105

556.18

10

556.03

10

C106

556.18

10

556.03

10

C107

556.18

10

556.03

10

C108

555.8

10

555.65

10

C109

555.8

10

555.65

10

RC101

1227.37

14

1131.64

14

RC102

1203.05

12

1168.31

12

RC103

923.15

11

911.6

11

RC104

787.02

10

794.4

10

RC105

1195.2

13

1044.4

13

RC106

1095.65

11

993.29

11

RC107

861.28

11

846.53

11

RC108

831.09

10

824.12

10

3249

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

Tabela 2 Resultados para R2, C2 e RC2
Repoussis(2009)
Conjunto

Tabela 4 Resultados para R2, C2 e RC2

GRASP+ILS

Distancia

Veculos

Distancia

Veculos

R201

1182.43

4

1198.06

4

R202

1149.59

3

1179.32

R203

889.12

3

R204

801.46

R205

Repoussis (2009)

GRASP+MMAS+ILS

Distancia

Veculos

Distancia

Veculos

R201

1182,43

4

1202,81

4

3

R202

1149,59

3

1044,2

4

923.51

3

R203

889,12

3

907,53

3

2

760.2

3

R204

801,46

2

750

3

943.33

3

1008.34

3

R205

943,33

3

1011,05

3

R206

869.27

3

894.39

3

R206

869,27

3

904,22

3

R207

857.08

2

790.98

3

R207

857,08

2

796,53

3

R208

700.53

2

703.4

2

R208

700,53

2

703,17

2

R209

851.69

3

876.52

3

R209

851,69

3

875,3

3

R210

892.45

3

901.07

3

R210

892,45

3

910,37

3

R211

886.9

2

761.22

3

R211

886,9

2

774,45

3

C201

548.51

3

548.3

3

C201

548,51

3

548,3

3

C202

548.51

3

548.3

3

C202

548,51

3

548,3

3

C203

548.13

3

630.6

3

C203

548,13

3

621,56

3

C204

547.55

3

618.54

3

C204

547,55

3

648,81

3

C205

545.83

3

545.61

3

C205

545,83

3

545,61

3

C206

545.45

3

545.22

3

C206

545,45

3

545,22

3

C207

545.24

3

545.01

3

C207

545,24

3

545,01

3

C208

545.28

3

545.05

3

C208

545,28

3

545,05

3

RC201

1303.73

4

1349.95

4

RC201

1303,73

4

1332,35

4

RC202

1321.43

3

1349.95

3

RC202

1321,43

3

1087,7

4

RC203

993.29

3

1019.77

3

RC203

993,29

3

1039,92

3

RC204

718.97

3

785.72

3

RC204

718,97

3

797,38

3

RC205

1189.84

4

992.6

3

RC205

1189,84

4

983,05

3

RC206

1091.79

3

1098.27

3

RC206

1091,79

3

1114,22

3

RC207

998.7

3

1018.68

3

RC207

998,7

3

1042,01

3

RC208

769.4

3

838.34

3

RC208

769,4

3

799,15

3

Tabela 3 Resultados para R1, C1 e RC1
Repoussis (2009)
Conjunto

Conjunto

Tabela 5 Resultados para R1, C1 e RC1
GRASP+ILS

GRASP+MMAS+ILS

Distancia

Veculos

Distancia

Veculos

R101

1192,85

19

1195,13

18

R102

1079,39

17

1046,3

R103

1016,78

13

977,5

Conjunto

GRASP+MMAS+ILS

Distancia

Veculos

Distancia

Veculos

R101

1195,13

18

1195,13

18

17

R102

1046,29

17

1046,3

17

13

R103

984,97

13

977,5

13

R104

869,63

9

797,6

9

R104

791,43

9

797,6

9

R105

1055,04

14

1076,32

13

R105

1123,85

13

1076,32

13

R106

1000,95

12

985,79

12

R106

994,82

12

985,79

12

R107

912,99

10

929,65

10

R107

921,37

10

929,65

10

R108

760,3

9

763,67

9

R108

777,6

9

763,67

9

R109

934,53

11

979,62

11

R109

954,19

11

979,62

11

R110

846,49

10

875,79

10

R110

904,16

10

875,79

10

R111

895,21

10

895,49

10

R111

887,21

10

895,49

10

R112

811,73

9

737,03

10

R112

750,21

10

737,03

10

C101

556,18

10

556,03

10

C101

556,03

10

556,03

10

C102

556,18

10

556,03

10

C102

556,03

10

556,03

10

C103

556,18

10

556,03

10

C103

556,03

10

556,03

10

C104

555,41

10

555,27

10

C104

555,27

10

555,27

10

C105

556,18

10

556,03

10

C105

556,03

10

556,03

10

C106

556,18

10

556,03

10

C106

556,03

10

556,03

10

C107

556,18

10

556,03

10

C107

556,03

10

556,03

10

C108

555,8

10

555,65

10

C108

555,65

10

555,65

10

C109

555,8

10

555,65

10

C109

555,65

10

555,65

10

RC101

1227,37

14

1130,06

14

RC101

1131,64

14

1130,06

14

RC102

1203,05

12

1043,16

13

RC102

1168,31

12

1043,16

13

RC103

923,15

11

911,8

11

RC103

911,6

11

911,8

11

RC104

787,02

10

804,43

10

RC104

794,4

10

804,43

10

RC105

1195,2

13

1045,77

13

RC105

1044,4

13

1045,77

13

RC106

1095,65

11

995,9

11

RC106

993,29

11

995,9

11

RC107

861,28

11

844,95

11

RC107

846,53

11

844,95

11

RC108

831,09

10

809,07

10

RC108

824,12

10

809,07

10

5

Conclusoes

Neste trabalho sao propostos os algoritmos hbridos GRASP+ILS e GRASP+MMAS+ILS para
a resolucao do PRAVJT, que e um problema
de otimizacao NPdifcil, o que requer o uso
de heursticas e me para solucionalo.
Tanto o algoritmo GRASP+ILS quanto
o GRASP+MMAS+ILS apresentaram resultados
competitivos e encontraram solucoes melhores
do que as presentes na literatura para 55, 36
e 50 das instancias testadas. O algoritmo
GRASP+ILS apresentou bons resultados conse-

ISBN 978-85-8001-069-5

guindo obter solucoes melhores do que as da literatura para mais de 58, 33 das instancias do
conjunto R1, 100 das instancias do conjunto C1,
87, 5 das instancias C2 e RC1. O algoritmo
GRASP+MMAS+ILS tambem apresentou resultados satisfatorios, alcancando solucoes melhores
do que as da literatura para mais de 50 das
instancias dos conjunto R1, 100 das instancias
do conjunto C1, 75 das instancias do conjunto
C2 e para 75 das instancias do conjunto RC1.
Em comparacao com GRASP+MMAS+ILS, o
algoritmo GRASP+ILS foi capaz de encontrar
um numero maior de solucoes melhores do que

3250

Anais do XIX Congresso Brasileiro de Automática, CBA 2012.

Tabela 6 Resultados para R2, C2 e RC2
GRASP+ILS
Conjunto

GRASP+MMAS+ILS

Distancia

Veculos

Distancia

Veculos

R201

1198,06

4

1202,81

4

R202

1179,32

3

1044,2

4

R203

923,51

3

907,53

3

R204

760,2

3

750

3

R205

1008,34

3

1011,05

3

R206

894,39

3

904,22

3

R207

790,98

3

796,53

3

R208

703,4

2

703,17

2

R209

876,52

3

875,3

3

R210

901,07

3

910,37

3

R211

761,22

3

774,45

3

C201

548,3

3

548,3

3

C202

548,3

3

548,3

3

C203

630,6

3

621,56

3

C204

618,54

3

648,81

3

C205

545,61

3

545,61

3

C206

545,22

3

545,22

3

C207

545,01

3

545,01

3

C208

545,05

3

545,05

3

RC201

1349,95

4

1332,35

4

RC202

1349,95

3

1087,7

4

RC203

1019,77

3

1039,92

3

RC204

785,72

3

797,38

3

RC205

992,6

3

983,05

3

RC206

1098,27

3

1114,22

3

RC207

1018,68

3

1042,01

3

RC208

838,34

3

799,15

3

as presentes na literatura. Na analise dos resultados obtidos pelos algoritmos GRASP+ILS
e GRASP+MMAS+ILS, percebeu-se que o primeiro apresentou solucoes melhores do que o segundo para mais de 41 das instancias, enquanto
que houve empate entre eles para 28, 57 das instancias restantes.
Agradecimentos
Os autores agradecem ao apoio oferecido pela CAPES, CEFET-MG e FAPEMIG.
Referencias
Brandao, J. (2004). A tabu search algorithm for
the open vehicle routing problem, European
Journal of Operation Research 157 552564.
Dorigo, M., Birattari, M. and Stutzle, T. (2006).
Ant colony optimization Artificial ants
as a computational intelligence technique,
IEEE Computational Intelligence Magazine
1(4) 2839.
Dorigo, M., Maniezzo, V. and Colorni, A. (1996).
Ant system Optimization by a colony of cooperating agents, IEEE Transactions on Systems, Man, and Cybernetics, Part B Cybernetics 26(1) 2941.
Dorigo, M. and Stutzle, T. (2003). The ant colony
optimization metaheuristic Algorithms, applications, and advances, in I. F. Glover and
G. A. Kochenberger (eds), Handbook of Metaheuristics, Kluwer Academic Publishers,
chapter 9, pp. 251285.

ISBN 978-85-8001-069-5

Feo, T. A. and Resende, M. G. C. (1995). Greedy randomized adaptive search procedures.,
Journal of Global Optimization pp. 109133.
Guiyun, L. (2009). An improved ant colony algorithm for open vehicle routing problem with
time windows, International Conference on
Information Management, Innovation Management and Industrial Engineering 2 616
619.
Letchford, A., Lysgaard, J. and Eglese, R. (2006).
A branch-and-cut algorithm for the capacitated open vehicle routing problem, Journal of
the Operational Research Society 58 1642
1651.
Li, F., Golden, B. and Wasil, E. (2007). The
open vehicle routing problem Algorithms,
large-scale test problems, and computational
results, Computers and Operations Research
34 29182930.
Lourenco, H., Martin, O. and Stutzle, T. (2003).
Iterated local search, in G. Glover, F. e Kochenberger (ed.), Handbook of Metaheuristics, Kluwer Academic Publishers, Boston,
pp. 321353.
MirHassani, S. and Abolghasemi, N. (2011). A
particle_swarm_optimization algorithm for
open vehicle routing problem, Expert Systems with Applications 38 1154711551.
Mladenovic, N. and Hansen, P. (1997). Variable
neighborhood search, Computers and Operations Research 24 10971100.
Repoussis, P., Tarantilis, C. and Ioannou, G.
(2006). The open vehicle routing problem
with time windows, Journal of the Operational Research Society 58 113.
Repoussis, P., Tarantilis, C. and Ioannou, G.
(2009). An evolutionary algorithm for the
open vehicle routing problem with time windows, Bio-inspired algorithms for the vehicle
routing problems 161 5575.
Schrage, L. (1981). Formulation and structure of
more complexrealistic routing and scheduling problems, Networks 11 229232.
Solomon, M. (1987). Algorithms for the vehicle routing and scheduling problems with
time window constraints, Operations Research 35 2544265.
Stutzle, T. and Hoos, H. H. (1996). Improving the
ant system A detailed report on the maxmin ant system, FG Intellektik, FB Informatik, TU Darmstadt, Germany, Tech. Rep. .
Stutzle, T. and Hoos, H. H. (2000). Max-min ant
system, Future Generation Computer Systems 16 889914.

3251